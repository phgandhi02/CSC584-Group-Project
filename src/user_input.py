"""
Module contains get_user_input function to select config params for procedurally
generating a level based on the user input. Function generates dict that contains
the parameters necessary to pass to the PCG generator functions.
"""


import json
import locale
from datetime import datetime
from pathlib import Path
from typing import Any
from collections import defaultdict

from src.llm import generate_level_config, DEFAULT_MODEL
from src.mission_to_geometry import adjust_layout_for_mission
from src.mission_processor import place_objectives

def get_user_input() -> dict[str, Any]:
    """Function to select config params for procedurally generating a level based on the user input.

    Returns:
        dict[str, Any]: contains the parameters necessary to pass to the PCG generator functions.
    """
    print("=== DunGen: Mission-Driven PCG Roguelike ===")
    print("\nDESCRIBE THE SETTING - The LLM will design a fitting mission!")
    print("\nQuick select (showcases all 6 algorithms):")
    print("  1. Classic dungeon with scattered rooms")
    print("  2. Organized military fortress")
    print("  3. Tight winding maze")
    print("  4. Natural underground cave")
    print("  5. Ancient citadel with hidden tunnels")
    print("  6. Gladiator arena with battle chambers")
    print("\nOr describe your own setting:")
    print("  TIP: Describe the ATMOSPHERE and PLACE!")
    print("  Examples:")
    print("    - 'creepy abandoned tomb with narrow passages'")
    print("    - 'grand cathedral with huge open chambers'")
    print("    - 'twisting natural caverns full of secrets'")
    print("    - 'tight military compound with organized rooms'")

    user_input: str = input("\nEnter 1-6 or describe setting (Enter for #1): ").strip()

    # Check if numeric choice - designed to showcase all 6 algorithms
    default_prompts = {
        "1": "classic dungeon with scattered rooms",
        "2": "organized military fortress",
        "3": "tight winding maze",
        "4": "natural underground cave",
        "5": "ancient citadel with hidden tunnels",
        "6": "gladiator arena with battle chambers",
    }

    user_prompt = default_prompts.get(user_input, user_input)

    if user_prompt:
        # Generate config from LLM
        print("\nGenerating level from your description...")
        try:
            config: dict[str, Any] = generate_custom_config(user_prompt)
        except Exception as e:
            print(f"Error generating config: {e}")
            print("Loading default config instead...")
            config_file_path = Path.joinpath(Path.cwd(), "jsons", "sample.json")
            with open(config_file_path, "r", encoding=locale.getencoding()) as f:
                config = json.load(f)
                return config
    else:
        # Load default config
        print("Loading default config instead...")
        config_file_path = Path.joinpath(Path.cwd(), "jsons", "sample.json")
        with open(config_file_path, "r", encoding=locale.getencoding()) as f:
            config = json.load(f)
            return config
    return config


def generate_custom_config(user_prompt: str) -> dict[str, Any]:
    """Generates a custom config dict based on the user prompt by passing the 
    input through an LLM and returning a dict of parameters generated by LLM.

    Args:
        user_prompt (str): User description of the level.

    Returns:
        dict[str, Any]: contains the parameters necessary to pass to the PCG generator functions.
    """
    level_config, log_data = generate_level_config(user_prompt, DEFAULT_MODEL)
    config: dict[str, Any] = level_config.model_dump()
    print(f"\nGenerated {config['algorithm']} level with {DEFAULT_MODEL}")

    # Show mission design (LLM invented this based on setting)
    if "mission" in config:
        mission = config["mission"]
        print(f"\n{'=' * 60}")
        print(f"  LLM-DESIGNED MISSION: {mission['mission_type'].upper()}")
        print("{'=' * 60}")
        print("Based on your setting, the LLM created this mission:")
        print(f"  {mission['description']}")
        print("\nObjectives to complete:")
        for i, obj in enumerate(mission["objectives"], 1):
            obj_name = obj["objective_type"].replace("_", " ").title()
            print(f"  {i}. {obj_name} x{obj['count']} - {obj['description']}")
        print(f"{'=' * 60}")

    # Save logs
    logs_dir = Path("logs")
    logs_dir.mkdir(exist_ok=True)

    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    log_file = logs_dir / f"generation_{timestamp}.json"

    with open(log_file, "w", encoding="utf-8") as f:
        json.dump(log_data, f, indent=2)
    print(f"Log saved to: {log_file}")

    return config

def verify_config_mission(config: dict[str, Any]) -> dict[str, Any]:
    """Adjusts the layout of the map based on the mission in the config file.

    Args:
        config (_type_): Parameters of the level design

    Returns:
        dict[str, Any]: Modify config based on the mission
    """
    # Adjust layout parameters based on mission (if present)
    if "mission" in config:
        original_layout = config["layout"].copy()
        config["layout"] = adjust_layout_for_mission(
            config["layout"],
            config["mission"],
            config["algorithm"],
        )

        print("\n{'=' * 60}")
        print("  MISSION-DRIVEN GEOMETRY ADJUSTMENTS")
        print("{'=' * 60}")
        # Show what changed
        changes = []
        for key in config["layout"]:
            if (
                key in original_layout
                and original_layout[key] != config["layout"][key]
            ):
                old_val = original_layout[key]
                new_val = config["layout"][key]
                if isinstance(old_val, (int, float)) and old_val != 0:
                    pct_change = ((new_val - old_val) / old_val) * 100
                    changes.append(
                        f"  {key}: {old_val} -> {new_val} ({pct_change:+.0f}%)"
                    )
                else:
                    changes.append(f"  {key}: {old_val} -> {new_val}")
        if changes:
            print("Mission requirements adjusted PCG parameters:")
            for change in changes:
                print(change)
            print("\nThe level geometry now FITS your mission!")
        else:
            print(
                "Algorithm already optimal for this mission - no changes needed!"
            )
        print(f"{'=' * 60}")

    return config

def place_mission_objectives(config: dict[str, Any], level_grid: list[list[int]]) -> dict[str, Any]:
    """
    Place mission objectives if mission exists
    """
    if "mission" in config:
        result: dict[str, Any] = place_objectives(level_grid, config["mission"])

        if "error" not in result:
            print("\n{'=' * 60}")
            print("  LEVEL GENERATION COMPLETE!")
            print("{'=' * 60}")
            print(
                f"Map Size: {len(level_grid[0])}x{len(level_grid)})"
            )
            print(f"Rooms Found: {result['num_rooms']}")
            print(f"Starting Position: {result['start_pos']}")
            print(f"Max Distance from Start: {result['max_distance']} tiles")

            total_objectives = sum(
                obj["count"] for obj in config["mission"]["objectives"]
            )
            print(
                f"\nObjectives Placed: {len(result['placements'])}/{total_objectives}"
            )

            # Group by type
            by_type: defaultdict[Any, list[Any]] = defaultdict(list)
            for p in result["placements"]:
                by_type[p["objective_type"]].append(p["placement_rule"])

            for obj_type, rules in sorted(by_type.items()):
                print(
                    f"  - {obj_type.replace('_', ' ').title()}: {len(rules)} placed"
                )

            print("\n*** Mission-optimized level ready! ***")
            print("{'=' * 60}\n")

            # Save placement info to config for rendering
            config["objective_placements"] = result["placements"]
            config["start_position"] = result["start_pos"]
    return config
